'''
Find the validity of an input string s that only contains the letters '(', ')' and '*'.



A string entered is legitimate if

Any left parenthesis '(' must have a corresponding right parenthesis ')'.
Any right parenthesis ')' must have a corresponding left parenthesis '('.
Left parenthesis '(' must go before the corresponding right parenthesis ')'.
'*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string "".

Examples:
Input : s = (*))

Output : true

Explanation : The * can be replaced by an opening '(' bracket. The string after replacing the * mark is "(())" and is a valid string.

Input : s = *(()

Output : false

Explanation : The * replaced with any bracket does not form a valid string.

Input : s = (**()))

Output:
true
Constraints:
1 <= s.length <= 104
s consist of only '(', ')', '*'.


#Brute
#Valid Parenthesis String - Recursion + DP Approach
Intuition
The problem is to check if a given string containing parentheses and asterisks can be considered a valid parenthesis string. A string is valid if each opening parenthesis has a corresponding closing parenthesis and they appear in the correct order. The asterisk can be replaced with an opening parenthesis, a closing parenthesis, or an empty character, adding complexity to the problem.

Detailed Thought Process
To solve the problem, imagine a simpler scenario without asterisks where the task is to validate a string of only parentheses. Using a counter to track the balance between opening and closing parentheses helps determine validity. Introducing asterisks requires considering all possible replacements for each asterisk. Recursion is an effective method to explore all combinations by treating each asterisk as three separate branches: an opening parenthesis, a closing parenthesis, and an empty character. This brute force approach will check all possible strings generated by these replacements.

Approach
Define a recursive function that takes the string, the current index, and the current count of open parentheses.
Base Case 1: If the count goes below zero at any point, return false.
Base Case 2: If the end of the string is reached, return true if the count is zero, otherwise false.
If the current character is an opening parenthesis, increase the count and recurse for the next index.
If the current character is a closing parenthesis, decrease the count and recurse for the next index.
If the current character is an asterisk, recurse three times: once treating it as an opening parenthesis, once as a closing parenthesis, and once as an empty character.
Memoize results to optimize and avoid redundant calculations.
class Solution:
    
    # Helper function to recursively check 
    # if the string is valid or not 
    def checkValid(self, ind, count, s, dp):
        # Base case 
        if count < 0: return False
        # Base case
        if ind == len(s):
            return count == 0

        # If already computed, return the value directly
        if dp[ind][count] != -1: return dp[ind][count]

        ans = False

        # If the current index has '('
        if s[ind] == '(':
            ans = self.checkValid(ind+1, count+1, s, dp)
        # If the current index has ')'
        elif s[ind] == ')':
            ans = self.checkValid(ind+1, count-1, s, dp)

        # else if the current index has '*'
        else:
            for i in range(-1, 2):
                ans = ans or self.checkValid(ind+1, count+i, s, dp)

        # Store the value in DP and return the value
        dp[ind][count] = ans
        return ans

    # Function to check if the given string is valid
    def isValid(self, s):
        n = len(s)
        
        # DP table
        dp = [[-1] * n for _ in range(n)]
        return self.checkValid(0, 0, s, dp)


# Driver Code
if __name__ == "__main__":
    s = "(*))"
    
    # Creating an instance of Solution class
    sol = Solution()
    
    # Function call to check if the string is valid
    ans = sol.isValid(s)
    
    if ans:
        print("The given string is valid.")
    else:
        print("The given string is not valid.")

Complexity Analysis
Time Complexity O(3n) : This is because, in the worst case, the function makes three recursive calls for each step, leading to an exponential growth of the number of calls.

Space Complexity O(n) :This is due to the space used by the recursion stack, which can go up to the depth of the input size n.

Valid Parenthesis String - Optimal Approach
Intuition
The optimal approach builds on the idea of balancing opening and closing parentheses but introduces a method to efficiently handle asterisks. By maintaining a range of possible balances (minimum and maximum count of open parentheses), the solution tracks the potential valid states as the string is processed. This range ensures that all valid configurations are considered without explicitly generating each possible string.

Detailed Thought Process
Instead of treating each asterisk as three separate branches in a recursion tree, maintain two variables representing the minimum and maximum possible number of open parentheses. As each character in the string is processed, update these variables accordingly. If an asterisk is encountered, adjust the range to reflect its three possible replacements. Throughout the process, ensure that the minimum number of open parentheses never goes negative. At the end of the string, check if the minimum count is zero to determine validity.

Approach
Initialize two variables, minOpen and maxOpen, to track the range of possible open parentheses.
Traverse the string character by character.
If an opening parenthesis is encountered, increment both minOpen and maxOpen.
If a closing parenthesis is encountered, decrement both minOpen and maxOpen.
If an asterisk is encountered, decrement minOpen (treat as closing), leave it unchanged (treat as empty), and increment maxOpen (treat as opening).
Ensure that minOpen never goes below zero.
After processing the string, check if minOpen is zero to determine if the string is valid.

class Solution(object):
    def isValid(self, s):
        minOpen, maxOpen = 0, 0
        for c in s:
            if c == '(':
                minOpen += 1 # Treat as opening
                maxOpen += 1 # Treat as opening
            elif c == ')':
                minOpen -= 1 # Treat as closing
                maxOpen -= 1 # Treat as closing
            elif c == '*':
                minOpen -= 1 # Treat as closing
                maxOpen += 1 # Treat as opening
            if maxOpen < 0:
                return False # More closing parentheses than opening
            if minOpen < 0:
                minOpen = 0 # Reset minOpen if negative
        return minOpen == 0 # Check if balanced

if __name__ == "__main__":
    sol = Solution()
    s = "(({}))"
    print("true" if sol.isValid(s) else "false")

Complexity Analysis
Time Complexity O(N) : This is because the algorithm processes each element of the input exactly once, leading to a linear time complexity.

Space Complexity O(1) : This is due to the use of a constant amount of extra space regardless of the input size, making the space complexity constant.


'''
class Solution(object):
    def isValid(self, s):
        minOpen, maxOpen = 0, 0
        for c in s:
            if c == '(':
                minOpen += 1 
                maxOpen += 1
            elif c == ')':
                minOpen -= 1 
                maxOpen -= 1 
            elif c == '*':
                minOpen -= 1 
                maxOpen += 1 
            if maxOpen < 0:
                return False 
            if minOpen < 0:
                minOpen = 0 
        return minOpen == 0